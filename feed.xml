<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://landoty.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://landoty.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-12-23T23:30:16+00:00</updated><id>https://landoty.github.io/feed.xml</id><title type="html">Landen Doty</title><entry><title type="html">SMT Solvers for CTFs</title><link href="https://landoty.github.io/blog/2024/using-Z3-ctf/" rel="alternate" type="text/html" title="SMT Solvers for CTFs" /><published>2024-03-02T00:00:00+00:00</published><updated>2024-03-02T00:00:00+00:00</updated><id>https://landoty.github.io/blog/2024/using-Z3-ctf</id><content type="html" xml:base="https://landoty.github.io/blog/2024/using-Z3-ctf/"><![CDATA[<h3 id="what-is-smt">What is SMT?</h3>

<p>Satisfiability modulo theories, or <strong>SMT</strong> for short, is the problem of determining whether a particular formula is <em>satisfiable</em>. It is a common topic in computer science theory and is a generalization of <em>Boolean Satisfiability</em>, or <strong>SAT</strong>, which only handles boolean (True/False) formulas. SMT is widely used in program analysis and verification and is readily available in many popular programming languages (<a href="https://github.com/Z3Prover/z3">Z3 Python</a>).</p>

<p>SAT is, as far as we know, NP-complete, so SMT is NP-hard. However, researchers have determined a number theories that lead to <em>decidable</em> SMT problems and are added directly into the logic of SMT solvers.</p>

<h3 id="solvers">Solvers</h3>

<p>SMT <em>solvers</em> are automated tools that aid practicioners in solving relevant SMT problems. For example, SMT solvers are often used in <em>symbolic execution</em> engines to determine particular useful inputs to a program. Solvers can also be invoked directly for smaller problems, like CTFs which will be demonstrated here.</p>

<h4 id="example-smt">Example SMT</h4>

\[x &gt; 0 \wedge x \leq 5 \wedge x \bmod 3 = 0\]

<p>Obviously, this example is simple to evaluate - \(x = 3\) - but it goes to show the additional expressiveness of SMT in comparison to SAT. We can expand this example a bit to show that compound expressions can also be used in SMT.</p>

\[x, y &gt; 0 \wedge x + y \leq 5 \wedge x \bmod 3 = 0\]

<p>Here, the solver will determine satisfiable values for both \(x\) and \(y\), returning the set, \(\{x: 3, y: 2\}\).</p>

<h3 id="z3py">Z3Py</h3>

<p>Z3 is a popular SMT solver/prover developed by <a href="https://www.microsoft.com/en-us/research/project/z3-3/">Microsoft</a> and is the target of many software engineering and verification tasks. It is avaiable in many mainstream languages and can be installed via their respective package managers. Among them, Python provides a seemless API that enables quick scripting that applies nicely to CTF challenges.</p>

<h4 id="install">Install</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>pip <span class="nb">install </span>z3-solver
</code></pre></div></div>

<h4 id="basic-z3-example">Basic Z3 Example</h4>

<p>The examples from above, solved using Z3Py</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">z3</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">x</span> <span class="o">=</span> <span class="nc">Int</span><span class="p">(</span><span class="sh">'</span><span class="s">x</span><span class="sh">'</span><span class="p">)</span> <span class="c1"># creating a Z3-aware variable, "x"
</span><span class="nf">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>Running this, we should expect \(x = 3\), as above.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 ./z3-example.py
<span class="o">[</span>x <span class="o">=</span> 3]
</code></pre></div></div>
<h4 id="using-the-solver-object">Using the solver object</h4>

<p>Z3Py also provides a solver object that can be instantiated to manage the constraint environment. Here, multiple constraints can be added incrementally to the solver. We can even check the state of the solver by printing it.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">z3</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">solver</span> <span class="o">=</span> <span class="nc">Solver</span><span class="p">()</span> <span class="c1"># instantiate a solver object
</span>
<span class="n">x</span> <span class="o">=</span> <span class="nc">Int</span><span class="p">(</span><span class="sh">'</span><span class="s">x</span><span class="sh">'</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="nc">Int</span><span class="p">(</span><span class="sh">'</span><span class="s">y</span><span class="sh">'</span><span class="p">)</span>

<span class="n">solver</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">x</span>  <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># add multiple constraints at once
</span><span class="n">solver</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="c1"># add complex expression as a constraint
</span><span class="n">solver</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="n">solver</span><span class="p">)</span> <span class="c1"># get the current state of the solver
</span></code></pre></div></div>

<p>Running this, we now get the set of constraints specified above.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 ./z3-example.py
<span class="o">[</span>x <span class="o">&gt;</span> 0, y <span class="o">&gt;</span> 0, x + y <span class="o">&gt;=</span> 5, x%3 <span class="o">==</span> 0]
</code></pre></div></div>

<p>In some cases, it may not be necessary to know <em>what</em> the satisfying values are, just <em>if</em> they can be satisfied. The solver allows us to check this using the <code class="language-plaintext highlighter-rouge">check()</code> method.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="bp">...</span>
<span class="nf">print</span><span class="p">(</span><span class="n">solver</span><span class="p">.</span><span class="nf">check</span><span class="p">())</span>
</code></pre></div></div>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 ./z3-example.py
sat
</code></pre></div></div>

<p>Now that we know the specified constraints are satisfiable, we can get a <em>model</em> of the constraints to retrieve satisfying values for \(x\) and \(y\).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="bp">...</span>
<span class="nf">print</span><span class="p">(</span><span class="n">solver</span><span class="p">.</span><span class="nf">model</span><span class="p">())</span>
</code></pre></div></div>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 ./z3-example.py
<span class="o">[</span>x <span class="o">=</span> 3, y <span class="o">=</span> 2]
</code></pre></div></div>

<h3 id="example-ctf-solution">Example CTF Solution</h3>

<p>Sparing the manual binary RE work, I came across a simple CTF challenge that seemed like a good candiate for SMT rather than other techniques (fuzzing, etc.).</p>

<p>The basic overview of the goes as follows:</p>

<ol>
  <li>Program takes 17 characters as input from stdin and stores in an array</li>
  <li>Swap the 12th and 16th index</li>
  <li>XOR each even index with 0xe0</li>
  <li>XOR each odd index with 0x3c</li>
  <li>Sort the array in ascending order</li>
  <li>Compare the resulting array with a key array, returning the flag if they match</li>
</ol>

<p>This particular challenge outputs the key array values, but it could also be extracted from further analysis, if necessary.</p>

<h4 id="modeling-the-arrays">Modeling the arrays</h4>

<p>To solve this challenge, we’ll need to use the Z3 <code class="language-plaintext highlighter-rouge">BitVec</code> object in order to perform the bitwise XOR. Note, <code class="language-plaintext highlighter-rouge">BitVec</code> requires the bit length to be specified.</p>

<p>List comprehension can be used here instead of instantiating 17 separate <code class="language-plaintext highlighter-rouge">BitVec</code> variables. Again, the output list was determined from the output of the challenge. We also use an intermediate <code class="language-plaintext highlighter-rouge">xor</code> list - more on this later.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">z3</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">17</span>

<span class="n">inp</span> <span class="o">=</span> <span class="p">[</span><span class="nc">BitVec</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">x_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="sh">"</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
<span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0x49</span><span class="p">,</span> <span class="mh">0x4b</span><span class="p">,</span> <span class="mh">0x4e</span><span class="p">,</span> <span class="mh">0x4f</span><span class="p">,</span>  <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">,</span> <span class="mh">0x59</span><span class="p">,</span> <span class="mh">0x5d</span><span class="p">,</span> <span class="mh">0x82</span><span class="p">,</span> <span class="mh">0x86</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="mh">0x8b</span><span class="p">,</span> <span class="mh">0x8d</span><span class="p">,</span> <span class="mh">0x93</span><span class="p">,</span> <span class="mh">0x93</span><span class="p">,</span> <span class="mh">0x93</span><span class="p">,</span> <span class="mh">0x96</span><span class="p">]</span>
<span class="n">xor</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div></div>

<h4 id="swapping">Swapping</h4>

<p>It’s much simpler to swap the input now, before specifying constraints, than deriving some constraint that says input indeces 12 and 16 should be equal to some other indeces after XOR and sort.</p>

<p>Think how specifying a constraint like this might over-constrain possible solutions to the challenge…</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="bp">...</span>
<span class="n">solver</span> <span class="o">=</span> <span class="nc">Solver</span><span class="p">()</span>

<span class="n">inp</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="n">inp</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="n">inp</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="n">inp</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="xor">XOR</h4>

<p>We can simply iterate over the input list and specify constraints for each index of the output list after the XOR operations.</p>

<p>Note, that we <em>must</em> also constrain the XOR keys since the BitVec constructor doesn’t take a literal value parameter. I.e., you can’t do something like <code class="language-plaintext highlighter-rouge">BitVec(0xAA)</code> to create a BitVec that holds the hexadecimal value 0xAA.</p>

<p>Also note that the result of the XOR operation is added to the intermediate <code class="language-plaintext highlighter-rouge">xor</code> list. This will help us specifiy constraints for sorting.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="bp">...</span>
<span class="n">xor_even</span> <span class="o">=</span> <span class="nc">BitVec</span><span class="p">(</span><span class="sh">'</span><span class="s">x_even</span><span class="sh">'</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">xor_odd</span> <span class="o">=</span> <span class="nc">BitVec</span><span class="p">(</span><span class="sh">'</span><span class="s">x_odd</span><span class="sh">'</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="c1"># Must constrain the XOR keys
</span><span class="n">solver</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">xor_even</span> <span class="o">==</span> <span class="mh">0xe0</span><span class="p">)</span>
<span class="n">solver</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">xor_odd</span> <span class="o">==</span> <span class="mh">0x3c</span><span class="p">)</span>

<span class="n">xor_result</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
	<span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="n">xor_result</span> <span class="o">=</span> <span class="n">inp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">xor_even</span>
		<span class="n">solver</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">xor_result</span> <span class="o">==</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">xor_result</span> <span class="o">=</span> <span class="n">inp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">xor_odd</span>
		<span class="n">solver</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">xor_result</span> <span class="o">==</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

	<span class="n">xor</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">xor_result</span><span class="p">)</span> <span class="c1">## Add result of XOR to xor list
</span></code></pre></div></div>

<h4 id="sort">Sort</h4>

<p>Now, we can iterate over the <code class="language-plaintext highlighter-rouge">xor</code> list, which contains the bitwise XOR operations, and specify that it must be sorted in ascending order.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="bp">...</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">solver</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">xor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">xor</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div></div>

<h4 id="print-constraints">Print constraints</h4>

<p>While not included in my actual solution, we can check the constraints we’ve specified as done in the previous example. This demonstrates why using the <code class="language-plaintext highlighter-rouge">Solver</code> object is preferred when working with complex environments.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="n">solver</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 ./ctf-z3.py
<span class="o">[</span>x_even <span class="o">==</span> 224,
 x_odd <span class="o">==</span> 60,
 x_0 ^ x_even <span class="o">==</span> 73,
 x_1 ^ x_odd <span class="o">==</span> 75,
 x_2 ^ x_even <span class="o">==</span> 78,
 x_3 ^ x_odd <span class="o">==</span> 79,
 x_4 ^ x_even <span class="o">==</span> 85,
 x_5 ^ x_odd <span class="o">==</span> 85,
 x_6 ^ x_even <span class="o">==</span> 89,
...
 x_0 ^ x_even &lt;<span class="o">=</span> x_1 ^ x_odd,
 x_1 ^ x_odd &lt;<span class="o">=</span> x_2 ^ x_even,
 x_2 ^ x_even &lt;<span class="o">=</span> x_3 ^ x_odd,
 x_3 ^ x_odd &lt;<span class="o">=</span> x_4 ^ x_even,
 x_4 ^ x_even &lt;<span class="o">=</span> x_5 ^ x_odd,
 x_5 ^ x_odd &lt;<span class="o">=</span> x_6 ^ x_even,
...]
</code></pre></div></div>

<h4 id="check-satisfiability-and-get-solution">Check satisfiability and get solution</h4>

<p>Finally, we can check if the constraints we’ve specified for the challenge can be satisfied. If they are, we can get numeric, human-readable values or use the <code class="language-plaintext highlighter-rouge">sys</code> library to write their raw byte values to <code class="language-plaintext highlighter-rouge">stdout</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">solver</span><span class="p">.</span><span class="nf">check</span><span class="p">()</span> <span class="o">==</span> <span class="n">sat</span><span class="p">:</span>
	<span class="n">model</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="nf">model</span><span class="p">()</span>
	<span class="n">solution</span> <span class="o">=</span> <span class="p">[</span><span class="n">model</span><span class="p">.</span><span class="nf">evaluate</span><span class="p">(</span><span class="n">inp</span><span class="p">[</span><span class="n">i</span><span class="p">]).</span><span class="nf">as_long</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
	<span class="n">solution</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="n">solution</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="n">solution</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="c1">## Readable solution
</span>
    <span class="sh">'''</span><span class="s"> Raw byte solution
	solution = bytes(solution)
	sys.stdout.buffer.write(solution)
    </span><span class="sh">'''</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 ./ctf-z3.py
<span class="o">[</span>169, 119, 174, 115, 181, 105, 185, 97, 98, 186, 104, 183, 118, 175, 115, 175, 109]
</code></pre></div></div>

<h3 id="final-thoughts">Final Thoughts</h3>

<p>SMT is one of those interesting pieces of computer science theory that applies to practical problems in a relatively straightforward way. Tools like Z3 make it easily accessible for quick problems like CTFs, but have also seen recent attention in large projects.</p>

<p>A few useful resources for more SMT-based work:</p>

<p><a href="https://smt-workshop.cs.uiowa.edu/2023/">SMT International Workshop</a><br />
<a href="https://www.usenix.org/system/files/conference/woot12/woot12-final26.pdf">SMT Solvers for Software Security</a><br />
<a href="https://docs.angr.io/en/latest/core-concepts/solver.html">Constraint solving in Symbolic Execution (Angr)</a></p>]]></content><author><name></name></author><category term="ctf" /><summary type="html"><![CDATA[Writing a Z3 Python script to solve a CTF]]></summary></entry><entry><title type="html">Accelerating Rust Binary RE - Ideas and Goals</title><link href="https://landoty.github.io/blog/2024/my-research/" rel="alternate" type="text/html" title="Accelerating Rust Binary RE - Ideas and Goals" /><published>2024-01-23T00:00:00+00:00</published><updated>2024-01-23T00:00:00+00:00</updated><id>https://landoty.github.io/blog/2024/my-research</id><content type="html" xml:base="https://landoty.github.io/blog/2024/my-research/"><![CDATA[<p>In the rapidly-evolving landscape of binary reverse engineering, the emergence of new languages present new and unique challenges for analysts and reverse engineers. As I begin my graduate studies, I will be exploring novel techniques to accelerate Rust binary RE with the goal of providing a more efficient and effective experience to RE practicioners.</p>

<h2 id="1-efficient-decompilation">1. Efficient Decompilation</h2>

<p>Rust binaries, with their “inherent” safety, come with a price—larger size due to added runtime code for features like panics, stack unwinding, and bounds checking. My first goal is to develop a more efficient decompilation experience, enabling reverse engineers to navigate through these complexities and quicky identify user-written code emitted in the binary.</p>

<h2 id="2-reconstructing-the-memory-model">2. Reconstructing the Memory Model</h2>

<p>Understanding the memory model is paramount in Rust binary reverse engineering. My focus is on determining crucial components of the lifetime and ownership system used by Rust and then annotating these results in disassembly and decompilation. By deciphering these elements, analysts can more precisely identify the flow of data throughout Rust programs.</p>

<h2 id="3-harmonizing-calling-conventions">3. Harmonizing Calling Conventions</h2>

<p>Rust’s ability to emit varying calling conventions adds another layer of complexity to reverse engineering efforts. My goal is to harmonize these calling conventions, simplifying the tracking of parameters and their memory locations at the binary level. By bringing order to this variability, more precision is provided to the analyst and may also further assist decompilation.</p>

<h2 id="4-tool-development">4. Tool Development</h2>

<p>Research is only impactful if it translates into practical tools that can be readily utilized by the community. My final goal revolves around developing user-friendly tools that cater to the aforementioned objectives. To ensure accessibility specific to the RE community, I will focus mainly on integrating my results with the Ghidra SRE suite.</p>

<p>Stay tuned for further updates on this work. Feel free to contact me if you are interested in collaborating!</p>]]></content><author><name></name></author><category term="research" /><summary type="html"><![CDATA[A short on my research goals]]></summary></entry><entry><title type="html">Reading list</title><link href="https://landoty.github.io/blog/2024/what-im-reading/" rel="alternate" type="text/html" title="Reading list" /><published>2024-01-01T00:00:00+00:00</published><updated>2024-01-01T00:00:00+00:00</updated><id>https://landoty.github.io/blog/2024/what-im-reading</id><content type="html" xml:base="https://landoty.github.io/blog/2024/what-im-reading/"><![CDATA[<h3 id="february">February</h3>
<ul>
  <li>Still working on American Prometheus</li>
  <li>Some papers I liked this month:
    <ul>
      <li><a href="https://ieeexplore.ieee.org/document/9519385">Android Custom Permissions Demystified</a></li>
      <li><a href="https://www.cl.cam.ac.uk/research/srg/netos/papers/2003-xensosp.pdf">Xen and the Art of Virtualization</a></li>
    </ul>
  </li>
</ul>

<h3 id="january-2024">January 2024</h3>
<ul>
  <li>American Prometheus: The Triumph and Tragedy of J. Robert Oppenheimer</li>
  <li>More research papers:
    <ul>
      <li><a href="https://zhuohua.me/assets/ESORICS2022-FFIChecker.pdf">FFIChecker</a></li>
      <li><a href="https://arxiv.org/abs/2103.15420">SafeDrop</a></li>
      <li><a href="https://rcs.uwaterloo.ca/papers/bvt.pdf">BVT Scheduler</a></li>
    </ul>
  </li>
</ul>

<h3 id="october---december-2023">October - December 2023</h3>

<ul>
  <li>A whole lot of research papers
    <ul>
      <li>Presented on <a href="https://www.usenix.org/system/files/conference/osdi16/osdi16-williams-king.pdf">Shuffler</a> for EECS765</li>
      <li>A few other favorites:
        <ul>
          <li><a href="http://wenkewww.gtisc.gatech.edu/papers/runtimeaslr-ndss16.pdf">RuntimeASLR</a></li>
          <li><a href="https://dl.acm.org/doi/pdf/10.1145/3428204">How Do Programmers Unsafe Rust</a></li>
          <li><a href="https://arxiv.org/pdf/2205.14989.pdf">Combining E-Graphs with Abstract Interpreation</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="september-2023">September 2023</h3>

<ul>
  <li>Thinking in Systems: A Primer, Donella Meadows</li>
</ul>

<h3 id="august-2023">August 2023</h3>

<ul>
  <li>When Einstein Walked With Gödel: Excursions to the Edge of Thought, Jim Holt</li>
</ul>

<h3 id="june-2023">June 2023</h3>

<ul>
  <li>The Biggest Bluff, Maria Konnikova</li>
  <li>Hangover Square, Patrick Hamilton</li>
</ul>

<h3 id="may-2023">May 2023</h3>

<ul>
  <li>The Intelligent Investor, Benjamin Graham (studying this one)</li>
</ul>

<h3 id="april-2023">April 2023</h3>

<ul>
  <li>A Gentleman in Moscow, Amor Towles</li>
  <li>A Higher Loyalty, James Comey</li>
</ul>]]></content><author><name></name></author><category term="books" /><summary type="html"><![CDATA[keeping track of what I'm reading]]></summary></entry><entry><title type="html">Hack the Box - Exatlon Writeup</title><link href="https://landoty.github.io/blog/2023/htb-exatlon/" rel="alternate" type="text/html" title="Hack the Box - Exatlon Writeup" /><published>2023-05-26T00:00:00+00:00</published><updated>2023-05-26T00:00:00+00:00</updated><id>https://landoty.github.io/blog/2023/htb-exatlon</id><content type="html" xml:base="https://landoty.github.io/blog/2023/htb-exatlon/"><![CDATA[<h3 id="initial-analysis">Initial Analysis</h3>

<p>Download the challenge materials from Hack the Box, create a directory, extract, ready to go. We get a single executable, <em>exatlon_v1</em>. Run <em>file</em> to see what we’re working with.</p>

<p><img src="/assets/img/blog/htb-exatlon-1.png" class="img-fluid" /></p>

<p>No section header AND statically linked?? Let’s toss it in IDA and see what’s going on…</p>

<p><img src="/assets/img/blog/htb-exatlon-2.png" class="img-fluid" /></p>

<p>Ok, yep, this is a mess. The binary has pretty clearly been compressed or packed. Recently, I’ve been utilizing IDA’s string view instead of the default Unix <em>strings</em> command. Let’s see what we get.</p>

<p><img src="/assets/img/blog/htb-exatlon-3.png" class="img-fluid" /></p>

<p>Ahhhh, there we go. <a href="https://github.com/upx/upx">UPX</a>, the <em>“Ultimate Packer for eXecutables”</em> was used here to compress the binary. After downloading the repo and building from source, UPX also provides a decompress or unpack option. Use this and reload the new binary into IDA.</p>

<p><img src="/assets/img/blog/htb-exatlon-4.png" class="img-fluid" /></p>

<h3 id="source-analysis">Source Analysis</h3>

<blockquote>
  <p><strong>NOTE:</strong> Recall the binary is statically linked, so whichever libraries are included to make it work will be fully compiled into the binary and included in IDA’s analysis.</p>
</blockquote>

<p>After loading the decompressed binary, we see all of those imports. Note the name mangling, so we’re working with a binary compiled from C++! Thankfully, it’s not stripped, so let’s find the <em>main</em> function and see what’s going on.</p>

<p><img src="/assets/img/blog/htb-exatlon-5.png" class="img-fluid" /></p>

<p>If you expand the image above from IDA, you can see that after prompting for the password, a call is made to function <em>exatlon</em>, followed by a (wacky) overloaded <em>==</em>. Also following the call to <em>exatlon</em>, a strange string of numbers.</p>

<p>Now, I should admit the rabbit hole I went down, trying to understand the various standard libary classes used here (char_traits, basic_string, etc.) to make sense of the equivalence operator. After a bit of frustration, I figured it was time for dynamic analysis…</p>

<h3 id="dynamic-analysis-in-gdb">Dynamic Analysis in GDB</h3>

<p>The workflow here isn’t too complicated…set a breakpoint for the instruction following the call to <em>exatlon</em>, walkthrough the next few instructions before the <em>==</em> operator, and check out the registers.</p>

<p>When running, just give a single character; I did ‘a’.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>b exatlon(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;)
run
step
ni 2
info registers
</code></pre></div></div>
<p>At this point, the registers don’t look too promising…shouldn’t <em>rax</em> just have 0x61? If you’re running a standard gdb configuration, it might not be too obvious, but thanks to <a href="https://hugsy.github.io/gef/">gef</a>, or <em>GDB Enhanced Features</em>, this one jumped out at me pretty clearly.</p>

<p><img src="/assets/img/blog/htb-exatlon-7.png" class="img-fluid" /></p>

<p>What the function <em>exatlon</em> is doing, is actually returning a string via a char pointer (char *). We can confirm this by examining the value of <em>rax</em>. Note, I use char ** here as <em>rax</em> contains a pointer to the string.</p>

<p><img src="/assets/img/blog/htb-exatlon-8.png" class="img-fluid" /></p>

<p>Here, I make an assumption that <em>exatlon</em> takes an input string, does some defined computation on it, and returns a string derived from that computation. Then, the input-derived string is compared with the string we see loaded into <em>rsi</em> in which the program terminates on a match.</p>

<h3 id="solution">Solution</h3>

<p>So, if we can get the “exatlon-d” representation of <em>every</em> ASCII character, we can just map each value in the string being compared to it’s ASCII representation. This should get the flag.</p>

<ol>
  <li>
    <p>Get all <em>printable</em> ASCII characters</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> python3 <span class="nt">-c</span> <span class="s1">'for i in range(33,127):print(chr(i), end="")'</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Run binary inside gdb, giving the ascii characters as the “password”</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> b exatlon(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;)
 run
 step
 ni 2
</code></pre></div>    </div>
  </li>
  <li>
    <p>Inspect the value of <em>rax</em> to get the “exatlon-d” string</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> x/s *(char **)$rax
</code></pre></div>    </div>
  </li>
  <li>
    <p>Script for solution</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># Printable ascii chars and their representations after going through exatlon function
</span> <span class="n">ascii_chars</span> <span class="o">=</span> <span class="sh">"</span><span class="s">!</span><span class="se">\"</span><span class="s">#$%&amp;</span><span class="sh">'</span><span class="s">()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~</span><span class="sh">"</span>
 <span class="n">ascii_chars_exatlon</span> <span class="o">=</span> <span class="sh">"</span><span class="s">528 544 560 576 592 608 624 640 656 672 688 704 720 736 752 768 784 800 816 832 848 864 880 896 912 928 944 960 976 992 1008 1024 1040 1056 1072 1088 1104 1120 1136 1152 1168 1184 1200 1216 1232 1248 1264 1280 1296 1312 1328 1344 1360 1376 1392 1408 1424 1440 1456 1472 1488 1504 1520 1536 1552 1568 1584 1600 1616 1632 1648 1664 1680 1696 1712 1728 1744 1760 1776 1792 1808 1824 1840 1856 1872 1888 1904 1920 1936 1952 1968 1984 2000 2016</span><span class="sh">"</span>

 <span class="c1"># Exatlon-form flag found in binary
</span> <span class="n">flag_exatlon</span> <span class="o">=</span> <span class="sh">"</span><span class="s">1152 1344 1056 1968 1728 816 1648 784 1584 816 1728 1520 1840 1664 784 1632 1856 1520 1728 816 1632 1856 1520 784 1760 1840 1824 816 1584 1856 784 1776 1760 528 528 2000</span><span class="sh">"</span>

 <span class="c1"># list-ify each
</span> <span class="n">ascii_chars</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">ascii_chars</span><span class="p">)</span>
 <span class="n">ascii_chars_exatlon</span> <span class="o">=</span> <span class="n">ascii_chars_exatlon</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="p">)</span>
 <span class="n">flag_exatlon</span> <span class="o">=</span> <span class="n">flag_exatlon</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="p">)</span>

 <span class="n">ascii_exatlon_dict</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="n">ascii_chars_exatlon</span><span class="p">,</span> <span class="n">ascii_chars</span><span class="p">))</span>

 <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">flag_exatlon</span><span class="p">:</span>
     <span class="nf">print</span><span class="p">(</span><span class="n">ascii_exatlon_dict</span><span class="p">[</span><span class="n">char</span><span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="sh">""</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ol>]]></content><author><name></name></author><category term="ctf" /><summary type="html"><![CDATA[Challenge writeup]]></summary></entry><entry><title type="html">Pwn.College Reverse Engineering</title><link href="https://landoty.github.io/blog/2023/pwnCollege-revEng/" rel="alternate" type="text/html" title="Pwn.College Reverse Engineering" /><published>2023-04-25T00:00:00+00:00</published><updated>2023-04-25T00:00:00+00:00</updated><id>https://landoty.github.io/blog/2023/pwnCollege-revEng</id><content type="html" xml:base="https://landoty.github.io/blog/2023/pwnCollege-revEng/"><![CDATA[<h3 id="challenge-10">Challenge 1.0</h3>

<ul>
  <li>
    <p>The challenge compares a user-input “license key” with the expected value.</p>
  </li>
  <li>
    <p>The output of the program gives us insight into how our input is formatted and compared against the expected value</p>

    <p><img src="/assets/img/blog/pwn-rev1-1.png" class="img-fluid" /></p>
  </li>
  <li>
    <p>As we can see, the first 5 ASCII characters are consumed, converted to hex, and compared against the expected value</p>
  </li>
  <li>
    <p>We can simply convert the expected hex values to ASCII and supply as input to the challenge</p>
  </li>
</ul>

<details><summary><b>Solution</b></summary>
<p>

```bash
    $ python -c "print(chr(0x75)+chr(0x6d)+chr(0x6e)+chr(0x75)+chr(0x64))" | /challenge/babyrev_level1.0
```
</p>
</details>

<h3 id="challenge-11">Challenge 1.1</h3>

<ul>
  <li>
    <p>This challenge is still comparing an user-input “license key” against the expected value.</p>
  </li>
  <li>
    <p>However, we are no longer provided any information about how our key is processed and what the expected value is…time to reverse!</p>
  </li>
</ul>

<ol>
  <li>
    <p><strong>Debugging Symbols</strong> =&gt; None :/</p>

    <p><img src="/assets/img/blog/pwn-rev1-2.png" class="img-fluid" /></p>
  </li>
  <li>
    <p><strong>Strings</strong> =&gt; ;)</p>

    <ul>
      <li>
        <p>Using the <em>strings</em> command and grep’ing for a 5-length string, we get something promising…</p>

        <p><img src="/assets/img/blog/pwn-rev1-3.png" class="img-fluid" /></p>
      </li>
      <li>
        <p>Let’s modify this command to just pipe to the challenge binary:</p>

        <details><summary><b>Solution</b></summary>
  <p>
        
  ```bash
      $ strings /challenge/babyrev_level1.1 | egrep -E "^z.{4}" | /challenge/babyrev_level1.1
  ```
  </p>
  </details>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>BONUS: .data</strong></p>

    <ul>
      <li>
        <p>We can also dump the data section to read the license key (just as <em>strings</em> does)</p>

        <p><img src="/assets/img/blog/pwn-rev1-4.png" class="img-fluid" /></p>
      </li>
    </ul>
  </li>
</ol>]]></content><author><name></name></author><category term="ctf" /><summary type="html"><![CDATA[uploading some previous solutions from Pwn.College]]></summary></entry></feed>