<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://landoty.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://landoty.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-02-16T18:36:29+00:00</updated><id>https://landoty.github.io/feed.xml</id><title type="html">Landen Doty</title><entry><title type="html">Accelerating Rust Binary RE - Ideas and Goals</title><link href="https://landoty.github.io/blog/2024/my-research/" rel="alternate" type="text/html" title="Accelerating Rust Binary RE - Ideas and Goals" /><published>2024-01-23T00:00:00+00:00</published><updated>2024-01-23T00:00:00+00:00</updated><id>https://landoty.github.io/blog/2024/my-research</id><content type="html" xml:base="https://landoty.github.io/blog/2024/my-research/"><![CDATA[<p>In the rapidly-evolving landscape of binary reverse engineering, the emergence of new languages present new and unique challenges for analysts and reverse engineers. As I begin my graduate studies, I will be exploring novel techniques to accelerate Rust binary RE with the goal of providing a more efficient and effective experience to RE practicioners.</p>

<h2 id="1-efficient-decompilation">1. Efficient Decompilation</h2>

<p>Rust binaries, with their “inherent” safety, come with a price—larger size due to added runtime code for features like panics, stack unwinding, and bounds checking. My first goal is to develop a more efficient decompilation experience, enabling reverse engineers to navigate through these complexities and quicky identify user-written code emitted in the binary.</p>

<h2 id="2-reconstructing-the-memory-model">2. Reconstructing the Memory Model</h2>

<p>Understanding the memory model is paramount in Rust binary reverse engineering. My focus is on determining crucial components of the lifetime and ownership system used by Rust and then annotating these results in disassembly and decompilation. By deciphering these elements, analysts can more precisely identify the flow of data throughout Rust programs.</p>

<h2 id="3-harmonizing-calling-conventions">3. Harmonizing Calling Conventions</h2>

<p>Rust’s ability to emit varying calling conventions adds another layer of complexity to reverse engineering efforts. My goal is to harmonize these calling conventions, simplifying the tracking of parameters and their memory locations at the binary level. By bringing order to this variability, more precision is provided to the analyst and may also further assist decompilation.</p>

<h2 id="4-tool-development">4. Tool Development</h2>

<p>Research is only impactful if it translates into practical tools that can be readily utilized by the community. My final goal revolves around developing user-friendly tools that cater to the aforementioned objectives. To ensure accessibility specific to the RE community, I will focus mainly on integrating my results with the Ghidra SRE suite.</p>

<p>Stay tuned for further updates on this work. Feel free to contact me if you are interested in collaborating!</p>]]></content><author><name></name></author><category term="research" /><summary type="html"><![CDATA[A short on my research goals]]></summary></entry><entry><title type="html">Reading list</title><link href="https://landoty.github.io/blog/2024/what-im-reading/" rel="alternate" type="text/html" title="Reading list" /><published>2024-01-01T00:00:00+00:00</published><updated>2024-01-01T00:00:00+00:00</updated><id>https://landoty.github.io/blog/2024/what-im-reading</id><content type="html" xml:base="https://landoty.github.io/blog/2024/what-im-reading/"><![CDATA[<h3 id="february">February</h3>
<ul>
  <li>Still working on American Prometheus</li>
  <li>Some papers I liked this month:
    <ul>
      <li><a href="https://ieeexplore.ieee.org/document/9519385">Android Custom Permissions Demystified</a></li>
      <li><a href="https://www.cl.cam.ac.uk/research/srg/netos/papers/2003-xensosp.pdf">Xen and the Art of Virtualization</a></li>
    </ul>
  </li>
</ul>

<h3 id="january-2024">January 2024</h3>
<ul>
  <li>American Prometheus: The Triumph and Tragedy of J. Robert Oppenheimer</li>
  <li>More research papers:
    <ul>
      <li><a href="https://zhuohua.me/assets/ESORICS2022-FFIChecker.pdf">FFIChecker</a></li>
      <li><a href="https://arxiv.org/abs/2103.15420">SafeDrop</a></li>
      <li><a href="https://rcs.uwaterloo.ca/papers/bvt.pdf">BVT Scheduler</a></li>
    </ul>
  </li>
</ul>

<h3 id="october---december-2023">October - December 2023</h3>

<ul>
  <li>A whole lot of research papers
    <ul>
      <li>Presented on <a href="https://www.usenix.org/system/files/conference/osdi16/osdi16-williams-king.pdf">Shuffler</a> for EECS765</li>
      <li>A few other favorites:
        <ul>
          <li><a href="http://wenkewww.gtisc.gatech.edu/papers/runtimeaslr-ndss16.pdf">RuntimeASLR</a></li>
          <li><a href="https://dl.acm.org/doi/pdf/10.1145/3428204">How Do Programmers Unsafe Rust</a></li>
          <li><a href="https://arxiv.org/pdf/2205.14989.pdf">Combining E-Graphs with Abstract Interpreation</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="september-2023">September 2023</h3>

<ul>
  <li>Thinking in Systems: A Primer, Donella Meadows</li>
</ul>

<h3 id="august-2023">August 2023</h3>

<ul>
  <li>When Einstein Walked With Gödel: Excursions to the Edge of Thought, Jim Holt</li>
</ul>

<h3 id="june-2023">June 2023</h3>

<ul>
  <li>The Biggest Bluff, Maria Konnikova</li>
  <li>Hangover Square, Patrick Hamilton</li>
</ul>

<h3 id="may-2023">May 2023</h3>

<ul>
  <li>The Intelligent Investor, Benjamin Graham (studying this one)</li>
</ul>

<h3 id="april-2023">April 2023</h3>

<ul>
  <li>A Gentleman in Moscow, Amor Towles</li>
  <li>A Higher Loyalty, James Comey</li>
</ul>]]></content><author><name></name></author><category term="books" /><summary type="html"><![CDATA[keeping track of what I'm reading]]></summary></entry><entry><title type="html">Hack the Box - Exatlon Writeup</title><link href="https://landoty.github.io/blog/2023/htb-exatlon/" rel="alternate" type="text/html" title="Hack the Box - Exatlon Writeup" /><published>2023-05-26T00:00:00+00:00</published><updated>2023-05-26T00:00:00+00:00</updated><id>https://landoty.github.io/blog/2023/htb-exatlon</id><content type="html" xml:base="https://landoty.github.io/blog/2023/htb-exatlon/"><![CDATA[<h3 id="initial-analysis">Initial Analysis</h3>

<p>Download the challenge materials from Hack the Box, create a directory, extract, ready to go. We get a single executable, <em>exatlon_v1</em>. Run <em>file</em> to see what we’re working with.</p>

<p><img src="/assets/img/blog/htb-exatlon-1.png" class="img-fluid" /></p>

<p>No section header AND statically linked?? Let’s toss it in IDA and see what’s going on…</p>

<p><img src="/assets/img/blog/htb-exatlon-2.png" class="img-fluid" /></p>

<p>Ok, yep, this is a mess. The binary has pretty clearly been compressed or packed. Recently, I’ve been utilizing IDA’s string view instead of the default Unix <em>strings</em> command. Let’s see what we get.</p>

<p><img src="/assets/img/blog/htb-exatlon-3.png" class="img-fluid" /></p>

<p>Ahhhh, there we go. <a href="https://github.com/upx/upx">UPX</a>, the <em>“Ultimate Packer for eXecutables”</em> was used here to compress the binary. After downloading the repo and building from source, UPX also provides a decompress or unpack option. Use this and reload the new binary into IDA.</p>

<p><img src="/assets/img/blog/htb-exatlon-4.png" class="img-fluid" /></p>

<h3 id="source-analysis">Source Analysis</h3>

<blockquote>
  <p><strong>NOTE:</strong> Recall the binary is statically linked, so whichever libraries are included to make it work will be fully compiled into the binary and included in IDA’s analysis.</p>
</blockquote>

<p>After loading the decompressed binary, we see all of those imports. Note the name mangling, so we’re working with a binary compiled from C++! Thankfully, it’s not stripped, so let’s find the <em>main</em> function and see what’s going on.</p>

<p><img src="/assets/img/blog/htb-exatlon-5.png" class="img-fluid" /></p>

<p>If you expand the image above from IDA, you can see that after prompting for the password, a call is made to function <em>exatlon</em>, followed by a (wacky) overloaded <em>==</em>. Also following the call to <em>exatlon</em>, a strange string of numbers.</p>

<p>Now, I should admit the rabbit hole I went down, trying to understand the various standard libary classes used here (char_traits, basic_string, etc.) to make sense of the equivalence operator. After a bit of frustration, I figured it was time for dynamic analysis…</p>

<h3 id="dynamic-analysis-in-gdb">Dynamic Analysis in GDB</h3>

<p>The workflow here isn’t too complicated…set a breakpoint for the instruction following the call to <em>exatlon</em>, walkthrough the next few instructions before the <em>==</em> operator, and check out the registers.</p>

<p>When running, just give a single character; I did ‘a’.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>b exatlon(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;)
run
step
ni 2
info registers
</code></pre></div></div>
<p>At this point, the registers don’t look too promising…shouldn’t <em>rax</em> just have 0x61? If you’re running a standard gdb configuration, it might not be too obvious, but thanks to <a href="https://hugsy.github.io/gef/">gef</a>, or <em>GDB Enhanced Features</em>, this one jumped out at me pretty clearly.</p>

<p><img src="/assets/img/blog/htb-exatlon-7.png" class="img-fluid" /></p>

<p>What the function <em>exatlon</em> is doing, is actually returning a string via a char pointer (char *). We can confirm this by examining the value of <em>rax</em>. Note, I use char ** here as <em>rax</em> contains a pointer to the string.</p>

<p><img src="/assets/img/blog/htb-exatlon-8.png" class="img-fluid" /></p>

<p>Here, I make an assumption that <em>exatlon</em> takes an input string, does some defined computation on it, and returns a string derived from that computation. Then, the input-derived string is compared with the string we see loaded into <em>rsi</em> in which the program terminates on a match.</p>

<h3 id="solution">Solution</h3>

<p>So, if we can get the “exatlon-d” representation of <em>every</em> ASCII character, we can just map each value in the string being compared to it’s ASCII representation. This should get the flag.</p>

<ol>
  <li>
    <p>Get all <em>printable</em> ASCII characters</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> python3 <span class="nt">-c</span> <span class="s1">'for i in range(33,127):print(chr(i), end="")'</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Run binary inside gdb, giving the ascii characters as the “password”</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> b exatlon(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;)
 run
 step
 ni 2
</code></pre></div>    </div>
  </li>
  <li>
    <p>Inspect the value of <em>rax</em> to get the “exatlon-d” string</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> x/s *(char **)$rax
</code></pre></div>    </div>
  </li>
  <li>
    <p>Script for solution</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># Printable ascii chars and their representations after going through exatlon function
</span> <span class="n">ascii_chars</span> <span class="o">=</span> <span class="sh">"</span><span class="s">!</span><span class="se">\"</span><span class="s">#$%&amp;</span><span class="sh">'</span><span class="s">()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~</span><span class="sh">"</span>
 <span class="n">ascii_chars_exatlon</span> <span class="o">=</span> <span class="sh">"</span><span class="s">528 544 560 576 592 608 624 640 656 672 688 704 720 736 752 768 784 800 816 832 848 864 880 896 912 928 944 960 976 992 1008 1024 1040 1056 1072 1088 1104 1120 1136 1152 1168 1184 1200 1216 1232 1248 1264 1280 1296 1312 1328 1344 1360 1376 1392 1408 1424 1440 1456 1472 1488 1504 1520 1536 1552 1568 1584 1600 1616 1632 1648 1664 1680 1696 1712 1728 1744 1760 1776 1792 1808 1824 1840 1856 1872 1888 1904 1920 1936 1952 1968 1984 2000 2016</span><span class="sh">"</span>

 <span class="c1"># Exatlon-form flag found in binary
</span> <span class="n">flag_exatlon</span> <span class="o">=</span> <span class="sh">"</span><span class="s">1152 1344 1056 1968 1728 816 1648 784 1584 816 1728 1520 1840 1664 784 1632 1856 1520 1728 816 1632 1856 1520 784 1760 1840 1824 816 1584 1856 784 1776 1760 528 528 2000</span><span class="sh">"</span>

 <span class="c1"># list-ify each
</span> <span class="n">ascii_chars</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">ascii_chars</span><span class="p">)</span>
 <span class="n">ascii_chars_exatlon</span> <span class="o">=</span> <span class="n">ascii_chars_exatlon</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="p">)</span>
 <span class="n">flag_exatlon</span> <span class="o">=</span> <span class="n">flag_exatlon</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="p">)</span>

 <span class="n">ascii_exatlon_dict</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="n">ascii_chars_exatlon</span><span class="p">,</span> <span class="n">ascii_chars</span><span class="p">))</span>

 <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">flag_exatlon</span><span class="p">:</span>
     <span class="nf">print</span><span class="p">(</span><span class="n">ascii_exatlon_dict</span><span class="p">[</span><span class="n">char</span><span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="sh">""</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ol>]]></content><author><name></name></author><category term="ctf" /><summary type="html"><![CDATA[Challenge writeup]]></summary></entry><entry><title type="html">Pwn.College Reverse Engineering</title><link href="https://landoty.github.io/blog/2023/pwnCollege-revEng/" rel="alternate" type="text/html" title="Pwn.College Reverse Engineering" /><published>2023-04-25T00:00:00+00:00</published><updated>2023-04-25T00:00:00+00:00</updated><id>https://landoty.github.io/blog/2023/pwnCollege-revEng</id><content type="html" xml:base="https://landoty.github.io/blog/2023/pwnCollege-revEng/"><![CDATA[<h3 id="challenge-10">Challenge 1.0</h3>

<ul>
  <li>
    <p>The challenge compares a user-input “license key” with the expected value.</p>
  </li>
  <li>
    <p>The output of the program gives us insight into how our input is formatted and compared against the expected value</p>

    <p><img src="/assets/img/blog/pwn-rev1-1.png" class="img-fluid" /></p>
  </li>
  <li>
    <p>As we can see, the first 5 ASCII characters are consumed, converted to hex, and compared against the expected value</p>
  </li>
  <li>
    <p>We can simply convert the expected hex values to ASCII and supply as input to the challenge</p>
  </li>
</ul>

<details><summary><b>Solution</b></summary>
<p>

```bash
    $ python -c "print(chr(0x75)+chr(0x6d)+chr(0x6e)+chr(0x75)+chr(0x64))" | /challenge/babyrev_level1.0
```
</p>
</details>

<h3 id="challenge-11">Challenge 1.1</h3>

<ul>
  <li>
    <p>This challenge is still comparing an user-input “license key” against the expected value.</p>
  </li>
  <li>
    <p>However, we are no longer provided any information about how our key is processed and what the expected value is…time to reverse!</p>
  </li>
</ul>

<ol>
  <li>
    <p><strong>Debugging Symbols</strong> =&gt; None :/</p>

    <p><img src="/assets/img/blog/pwn-rev1-2.png" class="img-fluid" /></p>
  </li>
  <li>
    <p><strong>Strings</strong> =&gt; ;)</p>

    <ul>
      <li>
        <p>Using the <em>strings</em> command and grep’ing for a 5-length string, we get something promising…</p>

        <p><img src="/assets/img/blog/pwn-rev1-3.png" class="img-fluid" /></p>
      </li>
      <li>
        <p>Let’s modify this command to just pipe to the challenge binary:</p>

        <details><summary><b>Solution</b></summary>
  <p>
        
  ```bash
      $ strings /challenge/babyrev_level1.1 | egrep -E "^z.{4}" | /challenge/babyrev_level1.1
  ```
  </p>
  </details>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>BONUS: .data</strong></p>

    <ul>
      <li>
        <p>We can also dump the data section to read the license key (just as <em>strings</em> does)</p>

        <p><img src="/assets/img/blog/pwn-rev1-4.png" class="img-fluid" /></p>
      </li>
    </ul>
  </li>
</ol>]]></content><author><name></name></author><category term="ctf" /><summary type="html"><![CDATA[uploading some previous solutions from Pwn.College]]></summary></entry></feed>